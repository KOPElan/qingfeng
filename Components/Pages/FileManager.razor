@page "/file-manager"
@using QingFeng.Services
@using QingFeng.Models
@using QingFeng.Utilities
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.FluentUI.AspNetCore.Components
@using Icon = Microsoft.FluentUI.AspNetCore.Components.Icon
@inject IFileManagerService FileManagerService
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@rendermode InteractiveServer

<PageTitle>Êñá‰ª∂ÁÆ°ÁêÜÂô®</PageTitle>

<style>
    .file-manager-container {
        display: flex;
        height: calc(100vh - 180px);
        gap: 0;
        max-width: 100%;
        margin: 0 auto;
    }
    
    .sidebar {
        width: 200px;
        background-color: var(--neutral-layer-1);
        border-right: 1px solid var(--neutral-stroke-divider-rest);
        overflow-y: auto;
        flex-shrink: 0;
    }
    
    .sidebar-section {
        padding: 16px 8px 8px 8px;
    }
    
    .sidebar-title {
        font-size: 12px;
        color: var(--neutral-foreground-hint);
        padding: 4px 12px;
        margin-bottom: 4px;
        font-weight: 500;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .sidebar-item {
        padding: 8px 12px;
        margin: 2px 4px;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        transition: background-color 0.2s;
    }
    
    .sidebar-item:hover {
        background-color: var(--neutral-fill-secondary-hover);
    }
    
    .sidebar-item.selected {
        background-color: var(--accent-fill-rest);
        color: white;
    }
    
    .sidebar-item i {
        font-size: 20px;
    }
    
    .main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    .toolbar {
        padding: 12px 24px;
        border-bottom: 1px solid var(--neutral-stroke-divider-rest);
        display: flex;
        align-items: center;
        gap: 8px;
        background-color: var(--neutral-layer-2);
    }
    
    .breadcrumb-container {
        display: flex;
        align-items: center;
        gap: 8px;
        flex: 1;
    }
    
    .breadcrumb {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 14px;
    }
    
    .breadcrumb-link {
        cursor: pointer;
        text-decoration: none;
        color: var(--accent-fill-rest);
    }
    
    .breadcrumb-link:hover {
        text-decoration: underline;
    }
    
    .file-count {
        font-size: 13px;
        color: var(--neutral-foreground-hint);
        margin-left: 8px;
    }
    
    .file-grid {
        padding: 24px;
        overflow-y: auto;
        flex: 1;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 20px;
        align-content: start;
    }
    
    .file-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    
    .file-item:hover {
        background-color: var(--neutral-fill-secondary-hover);
    }
    
    .file-item.selected {
        background-color: var(--accent-fill-rest);
        color: white;
    }
    
    .file-name {
        font-size: 13px;
        text-align: center;
        word-break: break-word;
        margin-bottom: 4px;
        margin-top: 8px;
    }
    
    .file-date {
        font-size: 11px;
        color: var(--neutral-foreground-hint);
    }
    
    .status-bar {
        padding: 8px 24px;
        border-top: 1px solid var(--neutral-stroke-divider-rest);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 13px;
        background-color: var(--neutral-layer-2);
    }
    
    .path-display {
        color: var(--neutral-foreground-hint);
    }
    
    .storage-info {
        color: var(--neutral-foreground-hint);
    }
    
    .fluent-table {
        width: 100%;
        border-collapse: collapse;
    }
    
    .fluent-table th {
        text-align: left;
        padding: 0.75rem;
        border-bottom: 2px solid var(--neutral-stroke-divider-rest);
        font-weight: 600;
    }
    
    .fluent-table td {
        padding: 0.75rem;
        border-bottom: 1px solid var(--neutral-stroke-divider-rest);
        vertical-align: middle;
    }
    
    .fluent-table tr:hover {
        background-color: var(--neutral-fill-secondary-hover);
    }
    
    .fluent-table tr.selected-row {
        background-color: var(--accent-fill-rest);
        color: white;
    }
</style>

<div class="file-manager-container">
    <!-- Left Sidebar -->
    <div class="sidebar">
        <!-- Favorites Section -->
        <div class="sidebar-section">
            <div class="sidebar-title">
                <span>Êî∂Ëóè</span>
                <FluentButton Appearance="Appearance.Stealth" 
                              IconOnly="true"
                              OnClick="ShowAddFavoriteDialog" 
                              Title="Ê∑ªÂä†ÂΩìÂâçÊñá‰ª∂Â§πÂà∞Êî∂Ëóè"
                              Style="padding: 0; min-width: auto;">
                    <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Add())" />
                </FluentButton>
            </div>
            @if (favoriteFolders != null && favoriteFolders.Any())
            {
                @foreach (var favorite in favoriteFolders)
                {
                    <div class="sidebar-item @(currentPath == favorite.Path ? "selected" : "")" 
                         @onclick="@(() => NavigateTo(favorite.Path))">
                        <i class="@GetFavoriteIcon(favorite.Icon)"></i>
                        <span style="flex: 1;">@favorite.Name</span>
                        <div @onclick:stopPropagation="true" style="display: flex; gap: 2px;">
                            <FluentButton Appearance="Appearance.Stealth" 
                                          IconOnly="true"
                                          OnClick="@(() => ShowEditFavoriteDialog(favorite))" 
                                          Title="ÁºñËæë"
                                          Style="padding: 0; min-width: auto;">
                                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Edit())" />
                            </FluentButton>
                            <FluentButton Appearance="Appearance.Stealth" 
                                          IconOnly="true"
                                          OnClick="@(() => RemoveFavorite(favorite.Id))" 
                                          Title="Âà†Èô§"
                                          Style="padding: 0; min-width: auto; color: var(--error);">
                                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.Delete())" />
                            </FluentButton>
                        </div>
                    </div>
                }
            }
            else
            {
                <div style="color: var(--neutral-foreground-hint); font-size: 12px; padding: 4px 12px;">ÊöÇÊó†Êî∂ËóèÊñá‰ª∂Â§π</div>
            }
        </div>

        <!-- Drives Section -->
        <div class="sidebar-section">
            <div class="sidebar-title">Â≠òÂÇ®</div>
            @if (drives != null)
            {
                @foreach (var drive in drives)
                {
                    <div class="sidebar-item @(currentPath == drive.Path || currentPath.StartsWith(drive.Path) ? "selected" : "")" 
                         @onclick="@(() => NavigateTo(drive.Path))">
                        <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Storage())" />
                        <span>@drive.Name</span>
                    </div>
                }
            }
        </div>
    </div>
    
    <!-- Main Content -->
    <div class="main-content">
        <!-- Notification Area -->
        @if (!string.IsNullOrEmpty(notificationMessage))
        {
            <div style="margin: 1rem;">
                <FluentMessageBar Intent="@(notificationIsError ? MessageIntent.Error : MessageIntent.Success)" 
                                  OnDismiss="ClearNotification">
                    @notificationMessage
                </FluentMessageBar>
            </div>
        }
        
        <!-- Toolbar -->
        <div class="toolbar">
            <FluentButton Appearance="Appearance.Stealth" 
                          IconOnly="true"
                          OnClick="GoBack" 
                          Disabled="@(navigationHistory.Count <= 1)"
                          Title="ÂêéÈÄÄ">
                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowLeft())" />
            </FluentButton>
            <FluentButton Appearance="Appearance.Stealth" 
                          IconOnly="true"
                          OnClick="GoForward" 
                          Disabled="@(forwardHistory.Count == 0)"
                          Title="ÂâçËøõ">
                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowRight())" />
            </FluentButton>
            
            <div class="breadcrumb-container">
                <div class="breadcrumb">
                    <span style="color: var(--neutral-foreground-hint);">Files</span>
                    @foreach (var part in GetPathParts())
                    {
                        <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size16.ChevronRight())" />
                        <a class="breadcrumb-link" @onclick="(() => NavigateTo(part.Path))">@part.Name</a>
                    }
                </div>
                @if (files != null)
                {
                    <span class="file-count">@files.Count È°π</span>
                }
            </div>
            
            <FluentButton Appearance="Appearance.Stealth" 
                          IconOnly="true"
                          OnClick="ShowUploadDialog" 
                          Title="‰∏ä‰º†Êñá‰ª∂">
                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowUpload())" />
            </FluentButton>
            <FluentButton Appearance="Appearance.Stealth" 
                          IconOnly="true"
                          OnClick="ShowCreateFolderDialog" 
                          Title="Êñ∞Âª∫Êñá‰ª∂Â§π">
                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.FolderAdd())" />
            </FluentButton>
            <FluentButton Appearance="Appearance.Stealth" 
                          IconOnly="true"
                          OnClick="ShowSearchDialog" 
                          Title="ÊêúÁ¥¢">
                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Search())" />
            </FluentButton>
            <FluentButton Appearance="Appearance.Stealth" 
                          IconOnly="true"
                          OnClick="RefreshFiles" 
                          Title="Âà∑Êñ∞">
                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowClockwise())" />
            </FluentButton>
            <FluentButton Appearance="Appearance.Stealth" 
                          IconOnly="true"
                          OnClick="ToggleViewMode" 
                          Title="ÂàáÊç¢ËßÜÂõæ">
                <FluentIcon Value="@((Icon)(isGridView ? new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.List() : new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.GridDots()))" />
            </FluentButton>
            <FluentButton Appearance="@(isSelectionMode ? Appearance.Accent : Appearance.Stealth)" 
                          IconOnly="true"
                          OnClick="ToggleSelectionMode" 
                          Title="@(isSelectionMode ? "ÈÄÄÂá∫ÈÄâÊã©Ê®°Âºè" : "ÈÄâÊã©Ê®°Âºè")">
                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.CheckboxChecked())" />
            </FluentButton>
        </div>
        
        <!-- Batch Operation Toolbar (shown when files are selected) -->
        @if (isSelectionMode && selectedFiles.Count > 0)
        {
            <div style="padding: 8px 24px; background-color: var(--accent-fill-rest); color: white; display: flex; align-items: center; gap: 8px;">
                <span style="flex: 1;">Â∑≤ÈÄâÊã© @selectedFiles.Count È°π</span>
                <FluentButton Appearance="Appearance.Lightweight" 
                              IconOnly="true"
                              OnClick="ShowBatchCopyDialog" 
                              Title="ÊâπÈáèÂ§çÂà∂"
                              Style="color: white;">
                    <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Copy())" />
                </FluentButton>
                <FluentButton Appearance="Appearance.Lightweight" 
                              IconOnly="true"
                              OnClick="ShowBatchMoveDialog" 
                              Title="ÊâπÈáèÁßªÂä®"
                              Style="color: white;">
                    <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowMove())" />
                </FluentButton>
                <FluentButton Appearance="Appearance.Lightweight" 
                              IconOnly="true"
                              OnClick="ShowBatchDeleteDialog" 
                              Title="ÊâπÈáèÂà†Èô§"
                              Style="color: white;">
                    <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Delete())" />
                </FluentButton>
                <FluentButton Appearance="Appearance.Lightweight" 
                              IconOnly="true"
                              OnClick="BatchDownloadFiles" 
                              Title="ÊâπÈáè‰∏ãËΩΩ"
                              Style="color: white;">
                    <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowDownload())" />
                </FluentButton>
                <FluentButton Appearance="Appearance.Lightweight" 
                              OnClick="@(() => selectedFiles.Clear())" 
                              Title="ÂèñÊ∂àÈÄâÊã©"
                              Style="color: white;">
                    ÂèñÊ∂àÈÄâÊã©
                </FluentButton>
            </div>
        }
        
        <!-- File Grid View -->
        @if (isGridView)
        {
            <div class="file-grid">
                @if (files != null && files.Any())
                {
                    @foreach (var file in files.Where(f => f.Name != ".."))
                    {
                        <div class="file-item @(IsFileSelected(file.Path) ? "selected" : "")" 
                             @onclick="@((e) => HandleFileItemClick(file.Path, e))" 
                             title="@file.Path"
                             style="position: relative;">
                            @if (isSelectionMode)
                            {
                                <div style="position: absolute; top: 8px; left: 8px; z-index: 1;" @onclick:stopPropagation="true">
                                    <FluentCheckbox Value="@IsFileSelected(file.Path)"
                                                    ValueChanged="@((bool _) => ToggleFileSelection(file.Path))" />
                                </div>
                            }
                            @if (file.IsDirectory)
                            {
                                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Folder())" Color="@Color.Custom" CustomColor="#FFA726" />
                            }
                            else
                            {
                                <FluentIcon Value="@((Icon)GetFluentFileIcon(file.Extension))" Color="@Color.Custom" CustomColor="#42A5F5" />
                            }
                            <div class="file-name">@file.Name</div>
                            @if (!file.IsDirectory)
                            {
                                <div class="file-date">@file.SizeDisplay</div>
                            }
                            <div class="file-date">@file.LastModified.ToString("dd/MM HH:mm")</div>
                        </div>
                    }
                }
                else if (files == null)
                {
                    <FluentStack HorizontalAlignment="HorizontalAlignment.Center" Style="grid-column: 1 / -1; padding: 3rem;">
                        <FluentProgressRing />
                    </FluentStack>
                }
            </div>
        }
        else
        {
            <!-- List View -->
            <div style="padding: 24px; overflow-y: auto; flex: 1;">
                @if (files != null && files.Any())
                {
                    <table class="fluent-table" role="table" aria-label="Êñá‰ª∂ÂàóË°®">
                        <thead>
                            <tr>
                                @if (isSelectionMode)
                                {
                                    <th scope="col" style="width: 50px;">
                                        <FluentCheckbox Value="@(selectedFiles.Count > 0 && selectedFiles.Count == SelectableFilesCount)"
                                                        ValueChanged="@((bool _) => ToggleSelectAll())"
                                                        Title="ÂÖ®ÈÄâ/ÂèñÊ∂àÂÖ®ÈÄâ" />
                                    </th>
                                }
                                <th scope="col">ÂêçÁß∞</th>
                                <th scope="col">Á±ªÂûã</th>
                                <th scope="col">Â§ßÂ∞è</th>
                                <th scope="col">‰øÆÊîπÊó∂Èó¥</th>
                                <th scope="col">Êìç‰Ωú</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var file in files)
                            {
                                <tr class="@(IsFileSelected(file.Path) ? "selected-row" : "")">
                                    @if (isSelectionMode && file.Name != "..")
                                    {
                                        <td @onclick:stopPropagation="true">
                                            <FluentCheckbox Value="@IsFileSelected(file.Path)"
                                                            ValueChanged="@((bool _) => ToggleFileSelection(file.Path))" />
                                        </td>
                                    }
                                    else if (isSelectionMode)
                                    {
                                        <td></td>
                                    }
                                    <td @onclick="@(() => HandleFileItemClick(file.Path, null))">
                                        @if (file.IsDirectory)
                                        {
                                            <div style="cursor: pointer; display: flex; align-items: center; gap: 0.5rem;">
                                                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Folder())" />
                                                @file.Name
                                            </div>
                                        }
                                        else
                                        {
                                            <div style="cursor: pointer; display: flex; align-items: center; gap: 0.5rem;">
                                                <FluentIcon Value="@((Icon)GetFluentFileIcon(file.Extension))" />
                                                <span>@file.Name</span>
                                            </div>
                                        }
                                    </td>
                                    <td>
                                        <FluentBadge Appearance="@(file.IsDirectory ? Appearance.Accent : Appearance.Neutral)">
                                            @(file.IsDirectory ? "Êñá‰ª∂Â§π" : "Êñá‰ª∂")
                                        </FluentBadge>
                                    </td>
                                    <td>@file.SizeDisplay</td>
                                    <td>@file.LastModified.ToString("yyyy-MM-dd HH:mm:ss")</td>
                                    <td>
                                        @if (!file.IsDirectory && file.Name != "..")
                                        {
                                            <FluentButton Appearance="Appearance.Stealth" 
                                                          IconOnly="true"
                                                          OnClick="(() => DownloadFile(file.Path))" 
                                                          Title="‰∏ãËΩΩ">
                                                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowDownload())" />
                                            </FluentButton>
                                        }
                                        @if (file.Name != "..")
                                        {
                                            <FluentButton Appearance="Appearance.Stealth" 
                                                          IconOnly="true"
                                                          OnClick="(() => ShowRenameDialog(file))" 
                                                          Title="ÈáçÂëΩÂêç">
                                                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Rename())" />
                                            </FluentButton>
                                            <FluentButton Appearance="Appearance.Stealth" 
                                                          IconOnly="true"
                                                          OnClick="(() => ShowCopyDialog(file))" 
                                                          Title="Â§çÂà∂">
                                                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Copy())" />
                                            </FluentButton>
                                            <FluentButton Appearance="Appearance.Stealth" 
                                                          IconOnly="true"
                                                          OnClick="(() => ShowMoveDialog(file))" 
                                                          Title="ÁßªÂä®">
                                                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.ArrowMove())" />
                                            </FluentButton>
                                        }
                                        @if (!file.IsDirectory && file.Name != "..")
                                        {
                                            <FluentButton Appearance="Appearance.Stealth" 
                                                          IconOnly="true"
                                                          OnClick="(() => DeleteFile(file.Path))" 
                                                          Title="Âà†Èô§"
                                                          Style="color: var(--error);">
                                                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Delete())" />
                                            </FluentButton>
                                        }
                                        @if (file.IsDirectory && file.Name != "..")
                                        {
                                            <FluentButton Appearance="Appearance.Stealth" 
                                                          IconOnly="true"
                                                          OnClick="(() => DeleteDirectory(file.Path))" 
                                                          Title="Âà†Èô§"
                                                          Style="color: var(--error);">
                                                <FluentIcon Value="@((Icon)new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Delete())" />
                                            </FluentButton>
                                        }
                                    </td>
                                </tr>
                            }
                        </tbody>
                    </table>
                }
                else if (files == null)
                {
                    <FluentStack HorizontalAlignment="HorizontalAlignment.Center" Style="padding: 3rem;">
                        <FluentProgressRing />
                    </FluentStack>
                }
                else
                {
                    <p>Ê≠§ÁõÆÂΩï‰∏∫Á©∫</p>
                }
            </div>
        }
        
        <!-- Status Bar -->
        <div class="status-bar">
            <div class="path-display">
                üìÇ @GetSimplifiedPath()
            </div>
            <div class="storage-info">
                @if (storageTotal > 0)
                {
                    <span>@FileUtilities.FormatSize(storageAvailable) ÂèØÁî®/@FileUtilities.FormatSize(storageTotal)</span>
                }
            </div>
        </div>
    </div>
</div>


<!-- Upload File Dialog -->
<FluentDialog Hidden="@(!showUploadDialog)" Modal="true" OnDismiss="CloseUploadDialog">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">‰∏ä‰º†Êñá‰ª∂</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical">
            <FluentLabel>ÈÄâÊã©Êñá‰ª∂</FluentLabel>
            <InputFile OnChange="HandleFileUpload" multiple />
            @if (!string.IsNullOrEmpty(uploadMessage))
            {
                <FluentMessageBar Intent="@(uploadSuccess ? MessageIntent.Success : MessageIntent.Error)">
                    @uploadMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="CloseUploadDialog">ÂÖ≥Èó≠</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Create Folder Dialog -->
<FluentDialog Hidden="@(!showCreateFolderDialog)" Modal="true" OnDismiss="CloseCreateFolderDialog">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">Êñ∞Âª∫Êñá‰ª∂Â§π</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical">
            <FluentLabel>Êñá‰ª∂Â§πÂêçÁß∞</FluentLabel>
            <FluentTextField @bind-Value="newFolderName" Placeholder="ËæìÂÖ•Êñá‰ª∂Â§πÂêçÁß∞" Style="width: 100%;" />
            @if (!string.IsNullOrEmpty(createFolderMessage))
            {
                <FluentMessageBar Intent="@(createFolderSuccess ? MessageIntent.Success : MessageIntent.Error)">
                    @createFolderMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="CloseCreateFolderDialog">ÂèñÊ∂à</FluentButton>
        <FluentButton Appearance="Appearance.Accent" OnClick="CreateFolder">ÂàõÂª∫</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Rename Dialog -->
<FluentDialog Hidden="@(!showRenameDialog)" Modal="true" OnDismiss="CloseRenameDialog">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">ÈáçÂëΩÂêç</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical">
            <FluentLabel>Êñ∞ÂêçÁß∞</FluentLabel>
            <FluentTextField @bind-Value="renameNewName" Placeholder="ËæìÂÖ•Êñ∞ÂêçÁß∞" Style="width: 100%;" />
            @if (!string.IsNullOrEmpty(renameMessage))
            {
                <FluentMessageBar Intent="@(renameSuccess ? MessageIntent.Success : MessageIntent.Error)">
                    @renameMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="CloseRenameDialog">ÂèñÊ∂à</FluentButton>
        <FluentButton Appearance="Appearance.Accent" OnClick="RenameItem">ÈáçÂëΩÂêç</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Copy Dialog -->
<FluentDialog Hidden="@(!showCopyDialog)" Modal="true" OnDismiss="CloseCopyDialog">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">Â§çÂà∂</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical">
            <FluentLabel>ÁõÆÊ†áË∑ØÂæÑ</FluentLabel>
            <FluentTextField @bind-Value="copyDestination" Placeholder="ËæìÂÖ•ÁõÆÊ†áË∑ØÂæÑ" Style="width: 100%;" />
            @if (!string.IsNullOrEmpty(copyMessage))
            {
                <FluentMessageBar Intent="@(copySuccess ? MessageIntent.Success : MessageIntent.Error)">
                    @copyMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="CloseCopyDialog">ÂèñÊ∂à</FluentButton>
        <FluentButton Appearance="Appearance.Accent" OnClick="CopyItem">Â§çÂà∂</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Move Dialog -->
<FluentDialog Hidden="@(!showMoveDialog)" Modal="true" OnDismiss="CloseMoveDialog">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">ÁßªÂä®</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical">
            <FluentLabel>ÁõÆÊ†áË∑ØÂæÑ</FluentLabel>
            <FluentTextField @bind-Value="moveDestination" Placeholder="ËæìÂÖ•ÁõÆÊ†áË∑ØÂæÑ" Style="width: 100%;" />
            @if (!string.IsNullOrEmpty(moveMessage))
            {
                <FluentMessageBar Intent="@(moveSuccess ? MessageIntent.Success : MessageIntent.Error)">
                    @moveMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="CloseMoveDialog">ÂèñÊ∂à</FluentButton>
        <FluentButton Appearance="Appearance.Accent" OnClick="MoveItem">ÁßªÂä®</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Search Dialog -->
<FluentDialog Hidden="@(!showSearchDialog)" Modal="true" OnDismiss="CloseSearchDialog" Style="min-width: 600px;">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">ÊêúÁ¥¢Êñá‰ª∂</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical">
            <FluentLabel>ÊêúÁ¥¢ÂÖ≥ÈîÆËØç</FluentLabel>
            <FluentStack Orientation="Orientation.Horizontal">
                <FluentTextField @bind-Value="searchPattern" Placeholder="ËæìÂÖ•Êñá‰ª∂ÂêçÊàñÊ®°ÂºèÔºåÂ¶Ç *.txt" Style="flex: 1;" />
                <FluentButton Appearance="Appearance.Accent" OnClick="SearchFiles">ÊêúÁ¥¢</FluentButton>
            </FluentStack>
            @if (searchResults != null && searchResults.Any())
            {
                <div style="max-height: 400px; overflow-y: auto;">
                    <table class="fluent-table" role="table" aria-label="ÊêúÁ¥¢ÁªìÊûú">
                        <thead>
                            <tr>
                                <th scope="col">ÂêçÁß∞</th>
                                <th scope="col">Ë∑ØÂæÑ</th>
                                <th scope="col">Á±ªÂûã</th>
                                <th scope="col">Â§ßÂ∞è</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var result in searchResults)
                            {
                                <tr style="cursor: pointer;" @onclick="(() => NavigateToSearchResult(result))">
                                    <td>
                                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                                            <FluentIcon Value="@((Icon)(result.IsDirectory ? new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Folder() : new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Document()))" />
                                            @result.Name
                                        </div>
                                    </td>
                                    <td>@result.Path</td>
                                    <td>@(result.IsDirectory ? "Êñá‰ª∂Â§π" : "Êñá‰ª∂")</td>
                                    <td>@result.SizeDisplay</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            }
            @if (searchResults != null && !searchResults.Any())
            {
                <FluentMessageBar Intent="MessageIntent.Info">Êú™ÊâæÂà∞ÂåπÈÖçÁöÑÊñá‰ª∂</FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="CloseSearchDialog">ÂÖ≥Èó≠</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Add/Edit Favorite Dialog -->
<FluentDialog Hidden="@(!showFavoriteDialog)" Modal="true" OnDismiss="CloseFavoriteDialog">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">@(editingFavorite == null ? "Ê∑ªÂä†Âà∞Êî∂Ëóè" : "ÁºñËæëÊî∂Ëóè")</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical">
            <FluentLabel>ÂêçÁß∞</FluentLabel>
            <FluentTextField @bind-Value="favoriteName" Placeholder="ËæìÂÖ•Êî∂ËóèÂ§πÂêçÁß∞" Style="width: 100%;" />
            
            @if (editingFavorite == null)
            {
                <FluentLabel>Ë∑ØÂæÑ</FluentLabel>
                <FluentTextField @bind-Value="favoritePath" Placeholder="Êñá‰ª∂Â§πË∑ØÂæÑ" ReadOnly="true" Style="width: 100%;" />
            }
            
            <FluentLabel>ÂõæÊ†á</FluentLabel>
            <FluentSelect TOption="string"
                          Items="@(new[] { "folder", "star", "description", "download", "photo_library", "movie", "audiotrack", "work", "school", "home" })"
                          OptionText="@GetFavoriteOptionText"
                          OptionValue="@(item => item)"
                          @bind-Value="favoriteIcon"
                          Style="width: 100%;" />
            
            @if (!string.IsNullOrEmpty(favoriteMessage))
            {
                <FluentMessageBar Intent="@(favoriteSuccess ? MessageIntent.Success : MessageIntent.Error)">
                    @favoriteMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="CloseFavoriteDialog">ÂèñÊ∂à</FluentButton>
        <FluentButton Appearance="Appearance.Accent" OnClick="SaveFavorite">‰øùÂ≠ò</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- File Preview Dialog -->
<FluentDialog Hidden="@(!showPreviewDialog)" Modal="true" OnDismiss="ClosePreviewDialog" Style="min-width: 800px;">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">Êñá‰ª∂È¢ÑËßà: @previewFileName</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <div style="max-height: 600px; overflow-y: auto;">
            @if (previewIsImage)
            {
                <div style="text-align: center;">
                    <img src="@previewImageUrl" alt="@previewFileName" style="max-width: 100%; max-height: 600px;" />
                </div>
            }
            else if (previewIsText)
            {
                <pre style="background-color: var(--neutral-layer-1); padding: 16px; border-radius: 8px; white-space: pre-wrap; word-wrap: break-word;">@previewTextContent</pre>
            }
            else if (previewIsPdf || previewIsDocx || previewIsXlsx)
            {
                <div id="documentPreviewContainer" style="background-color: var(--neutral-layer-2); color: var(--neutral-foreground-rest);">
                    <FluentStack HorizontalAlignment="HorizontalAlignment.Center" Style="padding: 3rem;">
                        <FluentProgressRing />
                        <FluentLabel>Ê≠£Âú®Âä†ËΩΩÊñáÊ°£È¢ÑËßà...</FluentLabel>
                    </FluentStack>
                </div>
            }
            else
            {
                <!-- Display file information for non-previewable files -->
                <FluentStack Orientation="Orientation.Vertical" Style="padding: 24px; align-items: center; gap: 16px;">
                    <div style="text-align: center;">
                        <FluentIcon Value="@((Icon)GetFluentFileIcon(Path.GetExtension(previewFilePath)))" 
                                    Color="@Color.Custom" 
                                    CustomColor="#42A5F5" 
                                    Style="font-size: 96px;" />
                    </div>
                    <FluentLabel Typo="Typography.Body" Style="font-size: 16px; text-align: center;">
                        Ê≠§Êñá‰ª∂Á±ªÂûãÊöÇ‰∏çÊîØÊåÅÂú®Á∫øÈ¢ÑËßà
                    </FluentLabel>
                    @if (!string.IsNullOrEmpty(previewFilePath) && File.Exists(previewFilePath))
                    {
                        var fileInfo = new FileInfo(previewFilePath);
                        <FluentStack Orientation="Orientation.Vertical" Style="width: 100%; gap: 12px; background-color: var(--neutral-layer-1); padding: 16px; border-radius: 8px;">
                            <FluentStack Orientation="Orientation.Horizontal" Style="justify-content: space-between;">
                                <FluentLabel Style="font-weight: 600;">Êñá‰ª∂Âêç:</FluentLabel>
                                <FluentLabel>@fileInfo.Name</FluentLabel>
                            </FluentStack>
                            <FluentStack Orientation="Orientation.Horizontal" Style="justify-content: space-between;">
                                <FluentLabel Style="font-weight: 600;">Êñá‰ª∂Â§ßÂ∞è:</FluentLabel>
                                <FluentLabel>@FileUtilities.FormatSize(fileInfo.Length)</FluentLabel>
                            </FluentStack>
                            <FluentStack Orientation="Orientation.Horizontal" Style="justify-content: space-between;">
                                <FluentLabel Style="font-weight: 600;">Êñá‰ª∂Á±ªÂûã:</FluentLabel>
                                <FluentLabel>@(string.IsNullOrEmpty(fileInfo.Extension) ? "Êú™Áü•" : fileInfo.Extension.ToUpperInvariant())</FluentLabel>
                            </FluentStack>
                            <FluentStack Orientation="Orientation.Horizontal" Style="justify-content: space-between;">
                                <FluentLabel Style="font-weight: 600;">‰øÆÊîπÊó∂Èó¥:</FluentLabel>
                                <FluentLabel>@fileInfo.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")</FluentLabel>
                            </FluentStack>
                            <FluentStack Orientation="Orientation.Horizontal" Style="justify-content: space-between;">
                                <FluentLabel Style="font-weight: 600;">ÂàõÂª∫Êó∂Èó¥:</FluentLabel>
                                <FluentLabel>@fileInfo.CreationTime.ToString("yyyy-MM-dd HH:mm:ss")</FluentLabel>
                            </FluentStack>
                        </FluentStack>
                    }
                </FluentStack>
            }
        </div>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Accent" OnClick="(() => DownloadFile(previewFilePath))">‰∏ãËΩΩ</FluentButton>
        <FluentButton Appearance="Appearance.Neutral" OnClick="ClosePreviewDialog">ÂÖ≥Èó≠</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Batch Copy Dialog -->
<FluentDialog Hidden="@(!showBatchCopyDialog)" Modal="true" OnDismiss="CloseBatchCopyDialog">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">ÊâπÈáèÂ§çÂà∂</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical">
            <FluentLabel>Â∑≤ÈÄâÊã© @selectedFiles.Count ‰∏™Êñá‰ª∂/Êñá‰ª∂Â§π</FluentLabel>
            <FluentLabel>ÁõÆÊ†áË∑ØÂæÑ</FluentLabel>
            <FluentTextField @bind-Value="batchCopyDestination" Placeholder="ËæìÂÖ•ÁõÆÊ†áË∑ØÂæÑ" Style="width: 100%;" />
            @if (!string.IsNullOrEmpty(batchCopyMessage))
            {
                <FluentMessageBar Intent="@(batchCopySuccess ? MessageIntent.Success : MessageIntent.Error)">
                    @batchCopyMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="CloseBatchCopyDialog">ÂèñÊ∂à</FluentButton>
        <FluentButton Appearance="Appearance.Accent" OnClick="BatchCopyFiles">Â§çÂà∂</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Batch Move Dialog -->
<FluentDialog Hidden="@(!showBatchMoveDialog)" Modal="true" OnDismiss="CloseBatchMoveDialog">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">ÊâπÈáèÁßªÂä®</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical">
            <FluentLabel>Â∑≤ÈÄâÊã© @selectedFiles.Count ‰∏™Êñá‰ª∂/Êñá‰ª∂Â§π</FluentLabel>
            <FluentLabel>ÁõÆÊ†áË∑ØÂæÑ</FluentLabel>
            <FluentTextField @bind-Value="batchMoveDestination" Placeholder="ËæìÂÖ•ÁõÆÊ†áË∑ØÂæÑ" Style="width: 100%;" />
            @if (!string.IsNullOrEmpty(batchMoveMessage))
            {
                <FluentMessageBar Intent="@(batchMoveSuccess ? MessageIntent.Success : MessageIntent.Error)">
                    @batchMoveMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="CloseBatchMoveDialog">ÂèñÊ∂à</FluentButton>
        <FluentButton Appearance="Appearance.Accent" OnClick="BatchMoveFiles">ÁßªÂä®</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

<!-- Batch Delete Confirmation Dialog -->
<FluentDialog Hidden="@(!showBatchDeleteDialog)" Modal="true" OnDismiss="CloseBatchDeleteDialog">
    <FluentDialogHeader>
        <FluentLabel Typo="Typography.H5">ÊâπÈáèÂà†Èô§Á°ÆËÆ§</FluentLabel>
    </FluentDialogHeader>
    <FluentDialogBody>
        <FluentStack Orientation="Orientation.Vertical">
            <FluentLabel>Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô @selectedFiles.Count ‰∏™Êñá‰ª∂/Êñá‰ª∂Â§πÂêóÔºü</FluentLabel>
            <FluentLabel Style="color: var(--error); font-size: 12px;">Ê≠§Êìç‰Ωú‰∏çÂèØÊí§ÈîÄÔºÅ</FluentLabel>
            @if (!string.IsNullOrEmpty(batchDeleteMessage))
            {
                <FluentMessageBar Intent="@(batchDeleteSuccess ? MessageIntent.Success : MessageIntent.Error)">
                    @batchDeleteMessage
                </FluentMessageBar>
            }
        </FluentStack>
    </FluentDialogBody>
    <FluentDialogFooter>
        <FluentButton Appearance="Appearance.Neutral" OnClick="CloseBatchDeleteDialog">ÂèñÊ∂à</FluentButton>
        <FluentButton Appearance="Appearance.Accent" OnClick="BatchDeleteFiles" Style="background-color: var(--error);">Âà†Èô§</FluentButton>
    </FluentDialogFooter>
</FluentDialog>

@code {
    private const int DIALOG_AUTO_CLOSE_DELAY_MS = 1000;
    
    private List<FileItemInfo>? files;
    private List<DriveItemInfo>? drives;
    private List<FavoriteFolder>? favoriteFolders;
    private string currentPath = string.Empty;
    private bool isGridView = true;
    private long storageTotal = 0;
    private long storageAvailable = 0;
    
    private Stack<string> navigationHistory = new Stack<string>();
    private Stack<string> forwardHistory = new Stack<string>();

    // Selection state
    private HashSet<string> selectedFiles = new HashSet<string>();
    private bool isSelectionMode = false;

    // Dialog states
    private bool showUploadDialog = false;
    private bool showCreateFolderDialog = false;
    private bool showRenameDialog = false;
    private bool showCopyDialog = false;
    private bool showMoveDialog = false;
    private bool showSearchDialog = false;
    private bool showPreviewDialog = false;
    private bool showFavoriteDialog = false;
    private bool showBatchCopyDialog = false;
    private bool showBatchMoveDialog = false;
    private bool showBatchDeleteDialog = false;

    // Dialog data
    private string newFolderName = string.Empty;
    private string renameNewName = string.Empty;
    private FileItemInfo? renameItem = null;
    private string copyDestination = string.Empty;
    private FileItemInfo? copyItem = null;
    private string moveDestination = string.Empty;
    private FileItemInfo? moveItem = null;
    private string searchPattern = string.Empty;
    private List<FileItemInfo>? searchResults = null;
    
    // Batch operation data
    private string batchCopyDestination = string.Empty;
    private string batchMoveDestination = string.Empty;
    private string batchCopyMessage = string.Empty;
    private bool batchCopySuccess = false;
    private string batchMoveMessage = string.Empty;
    private bool batchMoveSuccess = false;
    private string batchDeleteMessage = string.Empty;
    private bool batchDeleteSuccess = false;
    
    // Computed property for selectable files count
    private int SelectableFilesCount => files?.Where(f => f.Name != "..").Count() ?? 0;
    
    private string previewFilePath = string.Empty;
    private string previewFileName = string.Empty;
    private string previewImageUrl = string.Empty;
    private string previewTextContent = string.Empty;
    private bool previewIsImage = false;
    private bool previewIsText = false;
    private bool previewIsPdf = false;
    private bool previewIsDocx = false;
    private bool previewIsXlsx = false;
    private string previewFileUrl = string.Empty;

    // Favorite dialog data
    private FavoriteFolder? editingFavorite = null;
    private string favoriteName = string.Empty;
    private string favoritePath = string.Empty;
    private string favoriteIcon = "folder";
    private string favoriteMessage = string.Empty;
    private bool favoriteSuccess = false;

    // Messages
    private string uploadMessage = string.Empty;
    private bool uploadSuccess = false;
    private string createFolderMessage = string.Empty;
    private bool createFolderSuccess = false;
    private string renameMessage = string.Empty;
    private bool renameSuccess = false;
    private string copyMessage = string.Empty;
    private bool copySuccess = false;
    private string moveMessage = string.Empty;
    private bool moveSuccess = false;
    private string notificationMessage = string.Empty;
    private bool notificationIsError = false;

    protected override async Task OnInitializedAsync()
    {
        // Load drives, shortcuts, and favorites
        drives = await FileManagerService.GetDrivesAsync();        
        favoriteFolders = await FileManagerService.GetFavoriteFoldersAsync();
        
        // Start at user's home directory or first drive
        if (drives != null && drives.Any())
        {
            currentPath = drives.First().Path;
        }
        else if (OperatingSystem.IsWindows())
        {
            currentPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        }
        else
        {
            currentPath = "/";
        }
        
        navigationHistory.Push(currentPath);
        await RefreshFiles();
    }

    private async Task RefreshFiles()
    {
        try
        {
            files = await FileManagerService.GetFilesAsync(currentPath);
            var storage = await FileManagerService.GetStorageInfoAsync(currentPath);
            storageTotal = storage.total;
            storageAvailable = storage.available;
        }
        catch (Exception ex)
        {
            ShowNotification($"Âä†ËΩΩÊñá‰ª∂ÂàóË°®Â§±Ë¥•: {ex.Message}", true);
        }
    }

    private void ShowNotification(string message, bool isError = false)
    {
        notificationMessage = message;
        notificationIsError = isError;
        StateHasChanged();
    }

    private void ClearNotification()
    {
        notificationMessage = string.Empty;
        notificationIsError = false;
    }

    private async Task NavigateTo(string path)
    {
        if (Directory.Exists(path))
        {
            // Add current path to history if it's different
            if (currentPath != path)
            {
                navigationHistory.Push(currentPath);
                forwardHistory.Clear(); // Clear forward history on new navigation
            }
            
            currentPath = path;
            await RefreshFiles();
        }
        else if (File.Exists(path))
        {
            // Handle file click - always show preview dialog for all files
            await ShowFilePreview(path);
        }
    }

    private async Task GoBack()
    {
        if (navigationHistory.Count > 1)
        {
            forwardHistory.Push(currentPath);
            navigationHistory.Pop(); // Remove current
            currentPath = navigationHistory.Peek(); // Go to previous
            await RefreshFiles();
        }
    }

    private async Task GoForward()
    {
        if (forwardHistory.Count > 0)
        {
            navigationHistory.Push(currentPath);
            currentPath = forwardHistory.Pop();
            await RefreshFiles();
        }
    }

    private void ToggleViewMode()
    {
        isGridView = !isGridView;
    }

    private async Task DeleteFile(string path)
    {
        try
        {
            await FileManagerService.DeleteFileAsync(path);
            ShowNotification($"Êñá‰ª∂Â∑≤Âà†Èô§: {Path.GetFileName(path)}", false);
            await RefreshFiles();
        }
        catch (Exception ex)
        {
            ShowNotification($"Âà†Èô§Êñá‰ª∂Â§±Ë¥•: {ex.Message}", true);
        }
    }

    private async Task DeleteDirectory(string path)
    {
        try
        {
            await FileManagerService.DeleteDirectoryAsync(path);
            ShowNotification($"Êñá‰ª∂Â§πÂ∑≤Âà†Èô§: {Path.GetFileName(path)}", false);
            await RefreshFiles();
        }
        catch (Exception ex)
        {
            ShowNotification($"Âà†Èô§Êñá‰ª∂Â§πÂ§±Ë¥•: {ex.Message}", true);
        }
    }

    private List<(string Name, string Path)> GetPathParts()
    {
        var parts = new List<(string Name, string Path)>();
        
        if (string.IsNullOrEmpty(currentPath))
            return parts;
        
        var path = currentPath;
        var pathSegments = new List<string>();
        
        // Split path into segments
        while (!string.IsNullOrEmpty(path))
        {
            var dirInfo = new DirectoryInfo(path);
            if (dirInfo.Parent == null)
            {
                pathSegments.Insert(0, path);
                break;
            }
            pathSegments.Insert(0, dirInfo.Name);
            path = dirInfo.Parent.FullName;
        }
        
        // Build path parts
        var currentBuild = "";
        foreach (var segment in pathSegments)
        {
            if (string.IsNullOrEmpty(currentBuild))
            {
                currentBuild = segment;
            }
            else
            {
                currentBuild = Path.Combine(currentBuild, segment);
            }
            parts.Add((segment, currentBuild));
        }
        
        return parts;
    }

    private string GetSimplifiedPath()
    {
        if (string.IsNullOrEmpty(currentPath))
            return "/";
        
        var parts = currentPath.Split(Path.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length <= 3)
            return $"/ {string.Join(" / ", parts)}";
        
        return $"/ {parts[0]} / ... / {parts[parts.Length - 1]}";
    }

    private string GetShortcutIcon(string type)
    {
        return type switch
        {
            "documents" => Icons.Material.Filled.Description,
            "downloads" => Icons.Material.Filled.Download,
            "gallery" => Icons.Material.Filled.PhotoLibrary,
            "media" => Icons.Material.Filled.Movie,
            "backup" => Icons.Material.Filled.Backup,
            _ => Icons.Material.Filled.Folder
        };
    }

    private string GetFileIcon(string extension)
    {
        return extension.ToLowerInvariant() switch
        {
            ".pdf" => Icons.Material.Filled.PictureAsPdf,
            ".doc" or ".docx" => Icons.Material.Filled.Description,
            ".xls" or ".xlsx" => Icons.Material.Filled.TableChart,
            ".txt" or ".log" => Icons.Material.Filled.Description,
            ".jpg" or ".jpeg" or ".png" or ".gif" or ".bmp" or ".svg" or ".webp" => Icons.Material.Filled.Image,
            ".mp3" or ".wav" or ".flac" => Icons.Material.Filled.AudioFile,
            ".mp4" or ".avi" or ".mkv" or ".mov" => Icons.Material.Filled.VideoFile,
            ".zip" or ".rar" or ".7z" or ".tar" or ".gz" => Icons.Material.Filled.Archive,
            _ => Icons.Material.Filled.InsertDriveFile
        };
    }
    
    private Icon GetFluentFileIcon(string extension)
    {
        Icon icon = extension.ToLowerInvariant() switch
        {
            ".pdf" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Document(),
            ".doc" or ".docx" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Document(),
            ".xls" or ".xlsx" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Table(),
            ".txt" or ".log" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.DocumentText(),
            ".jpg" or ".jpeg" or ".png" or ".gif" or ".bmp" or ".svg" or ".webp" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Image(),
            ".mp3" or ".wav" or ".flac" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Speaker2(),
            ".mp4" or ".avi" or ".mkv" or ".mov" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Video(),
            ".zip" or ".rar" or ".7z" or ".tar" or ".gz" => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Archive(),
            _ => new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size48.Document()
        };
        return icon;
    }

    // File operation methods
    private async Task DownloadFile(string filePath)
    {
        try
        {
            var encodedPath = Uri.EscapeDataString(filePath);
            var downloadUrl = $"/api/files/download?path={encodedPath}";
            
            // Trigger download using JavaScript
            await JSRuntime.InvokeVoidAsync("open", downloadUrl, "_blank");
            ShowNotification($"ÂºÄÂßã‰∏ãËΩΩ: {Path.GetFileName(filePath)}", false);
        }
        catch (Exception ex)
        {
            ShowNotification($"‰∏ãËΩΩÊñá‰ª∂Â§±Ë¥•: {ex.Message}", true);
        }
    }

    // Dialog methods
    private void ShowUploadDialog()
    {
        showUploadDialog = true;
        uploadMessage = string.Empty;
        uploadSuccess = false;
    }

    private void CloseUploadDialog()
    {
        showUploadDialog = false;
        uploadMessage = string.Empty;
        uploadSuccess = false;
    }

    private async Task HandleFileUpload(InputFileChangeEventArgs e)
    {
        try
        {
            uploadMessage = string.Empty;
            var uploadResults = new System.Text.StringBuilder();
            var successCount = 0;
            var failCount = 0;
            
            foreach (var file in e.GetMultipleFiles())
            {
                try
                {
                    using var stream = file.OpenReadStream(maxAllowedSize: 1024 * 1024 * 100); // 100MB max
                    using var memoryStream = new MemoryStream();
                    await stream.CopyToAsync(memoryStream);
                    var buffer = memoryStream.ToArray();
                    
                    await FileManagerService.UploadFileAsync(currentPath, file.Name, buffer);
                    uploadResults.AppendLine($"ÊàêÂäü‰∏ä‰º†: {file.Name}");
                    successCount++;
                }
                catch (Exception ex)
                {
                    uploadResults.AppendLine($"‰∏ä‰º†Â§±Ë¥• {file.Name}: {ex.Message}");
                    failCount++;
                }
            }
            
            uploadMessage = uploadResults.ToString();
            uploadSuccess = failCount == 0; // Only success if all files uploaded
            await RefreshFiles();
        }
        catch (Exception ex)
        {
            uploadMessage = $"‰∏ä‰º†Â§±Ë¥•: {ex.Message}";
            uploadSuccess = false;
        }
    }

    private void ShowCreateFolderDialog()
    {
        showCreateFolderDialog = true;
        newFolderName = string.Empty;
        createFolderMessage = string.Empty;
        createFolderSuccess = false;
    }

    private void CloseCreateFolderDialog()
    {
        showCreateFolderDialog = false;
        newFolderName = string.Empty;
        createFolderMessage = string.Empty;
        createFolderSuccess = false;
    }

    private async Task CreateFolder()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(newFolderName))
            {
                createFolderMessage = "ËØ∑ËæìÂÖ•Êñá‰ª∂Â§πÂêçÁß∞";
                createFolderSuccess = false;
                return;
            }

            var folderPath = Path.Combine(currentPath, newFolderName);
            await FileManagerService.CreateDirectoryAsync(folderPath);
            
            createFolderMessage = "Êñá‰ª∂Â§πÂàõÂª∫ÊàêÂäü";
            createFolderSuccess = true;
            
            // Refresh files list separately to avoid overwriting success message
            try
            {
                await RefreshFiles();
            }
            catch
            {
                // Ignore refresh errors - folder was created successfully
            }
            
            CloseCreateFolderDialog();
        }
        catch (Exception ex)
        {
            createFolderMessage = $"ÂàõÂª∫Êñá‰ª∂Â§πÂ§±Ë¥•: {ex.Message}";
            createFolderSuccess = false;
        }
    }

    private void ShowRenameDialog(FileItemInfo item)
    {
        showRenameDialog = true;
        renameItem = item;
        renameNewName = item.Name;
        renameMessage = string.Empty;
        renameSuccess = false;
    }

    private void CloseRenameDialog()
    {
        showRenameDialog = false;
        renameItem = null;
        renameNewName = string.Empty;
        renameMessage = string.Empty;
        renameSuccess = false;
    }

    private async Task RenameItem()
    {
        try
        {
            if (renameItem == null || string.IsNullOrWhiteSpace(renameNewName))
            {
                renameMessage = "ËØ∑ËæìÂÖ•Êñ∞ÂêçÁß∞";
                renameSuccess = false;
                return;
            }

            var newPath = Path.Combine(Path.GetDirectoryName(renameItem.Path) ?? currentPath, renameNewName);
            await FileManagerService.RenameAsync(renameItem.Path, newPath);
            
            renameMessage = "ÈáçÂëΩÂêçÊàêÂäü";
            renameSuccess = true;
            
            try
            {
                await RefreshFiles();
            }
            catch
            {
                // Ignore refresh errors - rename was successful
            }
            
            CloseRenameDialog();
        }
        catch (Exception ex)
        {
            renameMessage = $"ÈáçÂëΩÂêçÂ§±Ë¥•: {ex.Message}";
            renameSuccess = false;
        }
    }

    private void ShowCopyDialog(FileItemInfo item)
    {
        showCopyDialog = true;
        copyItem = item;
        copyDestination = string.Empty; // Empty by default to avoid confusion
        copyMessage = string.Empty;
        copySuccess = false;
    }

    private void CloseCopyDialog()
    {
        showCopyDialog = false;
        copyItem = null;
        copyDestination = string.Empty;
        copyMessage = string.Empty;
        copySuccess = false;
    }

    private async Task CopyItem()
    {
        try
        {
            if (copyItem == null || string.IsNullOrWhiteSpace(copyDestination))
            {
                copyMessage = "ËØ∑ËæìÂÖ•ÁõÆÊ†áË∑ØÂæÑ";
                copySuccess = false;
                return;
            }

            var destPath = Path.Combine(copyDestination, copyItem.Name);
            await FileManagerService.CopyAsync(copyItem.Path, destPath);
            
            copyMessage = "Â§çÂà∂ÊàêÂäü";
            copySuccess = true;
            
            try
            {
                await RefreshFiles();
            }
            catch
            {
                // Ignore refresh errors - copy was successful
            }
            
            CloseCopyDialog();
        }
        catch (Exception ex)
        {
            copyMessage = $"Â§çÂà∂Â§±Ë¥•: {ex.Message}";
            copySuccess = false;
        }
    }

    private void ShowMoveDialog(FileItemInfo item)
    {
        showMoveDialog = true;
        moveItem = item;
        moveDestination = string.Empty; // Empty by default to avoid confusion
        moveMessage = string.Empty;
        moveSuccess = false;
    }

    private void CloseMoveDialog()
    {
        showMoveDialog = false;
        moveItem = null;
        moveDestination = string.Empty;
        moveMessage = string.Empty;
        moveSuccess = false;
    }

    private async Task MoveItem()
    {
        try
        {
            if (moveItem == null || string.IsNullOrWhiteSpace(moveDestination))
            {
                moveMessage = "ËØ∑ËæìÂÖ•ÁõÆÊ†áË∑ØÂæÑ";
                moveSuccess = false;
                return;
            }

            var destPath = Path.Combine(moveDestination, moveItem.Name);
            await FileManagerService.MoveAsync(moveItem.Path, destPath);
            
            moveMessage = "ÁßªÂä®ÊàêÂäü";
            moveSuccess = true;
            
            try
            {
                await RefreshFiles();
            }
            catch
            {
                // Ignore refresh errors - move was successful
            }
            
            CloseMoveDialog();
        }
        catch (Exception ex)
        {
            moveMessage = $"ÁßªÂä®Â§±Ë¥•: {ex.Message}";
            moveSuccess = false;
        }
    }

    private void ShowSearchDialog()
    {
        showSearchDialog = true;
        searchPattern = string.Empty;
        searchResults = null;
    }

    private void CloseSearchDialog()
    {
        showSearchDialog = false;
        searchPattern = string.Empty;
        searchResults = null;
    }

    private async Task SearchFiles()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(searchPattern))
            {
                ShowNotification("ËØ∑ËæìÂÖ•ÊêúÁ¥¢ÂÜÖÂÆπ", true);
                return;
            }

            searchResults = await FileManagerService.SearchFilesAsync(currentPath, searchPattern);
            
            // Warn if large number of results
            if (searchResults.Count > 1000)
            {
                ShowNotification($"ÊâæÂà∞ {searchResults.Count} ‰∏™ÁªìÊûúÔºåÊòæÁ§∫ÂèØËÉΩËæÉÊÖ¢", false);
            }
        }
        catch (Exception ex)
        {
            ShowNotification($"ÊêúÁ¥¢Â§±Ë¥•: {ex.Message}", true);
            searchResults = new List<FileItemInfo>();
        }
    }

    private async Task NavigateToSearchResult(FileItemInfo result)
    {
        CloseSearchDialog();
        
        if (result.IsDirectory)
        {
            await NavigateTo(result.Path);
        }
        else
        {
            var directory = Path.GetDirectoryName(result.Path);
            if (!string.IsNullOrEmpty(directory))
            {
                await NavigateTo(directory);
            }
        }
    }

    private bool IsPreviewableFile(string extension)
    {
        var imageExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp" };
        var textExtensions = new[] { ".txt", ".log", ".md", ".json", ".xml", ".csv", ".html", ".css", ".js", ".cs", ".razor", ".sh", ".conf", ".config", ".yml", ".yaml" };
        var pdfExtensions = new[] { ".pdf" };
        var officeExtensions = new[] { ".doc", ".docx", ".xls", ".xlsx" };
        
        return imageExtensions.Contains(extension) || textExtensions.Contains(extension) || 
               pdfExtensions.Contains(extension) || officeExtensions.Contains(extension);
    }

    private async Task ShowFilePreview(string filePath)
    {
        try
        {
            previewFilePath = filePath;
            previewFileName = Path.GetFileName(filePath);
            var extension = Path.GetExtension(filePath).ToLowerInvariant();
            
            var imageExtensions = new[] { ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp" };
            var textExtensions = new[] { ".txt", ".log", ".md", ".json", ".xml", ".csv", ".html", ".css", ".js", ".cs", ".razor", ".sh", ".conf", ".config", ".yml", ".yaml" };
            
            previewIsImage = imageExtensions.Contains(extension);
            previewIsText = textExtensions.Contains(extension);
            previewIsPdf = extension == ".pdf";
            previewIsDocx = extension == ".docx" || extension == ".doc";
            previewIsXlsx = extension == ".xlsx" || extension == ".xls";
            
            // Warn users about limited support for legacy formats
            if (extension == ".doc")
            {
                ShowNotification("ËØ•Êñá‰ª∂‰∏∫ÊóßÁâà Word (.doc) Ê†ºÂºèÔºåÂú®Á∫øÈ¢ÑËßàÂèØËÉΩ‰∏çÂÆåÊï¥ÊàñÊó†Ê≥ïÊòæÁ§∫„ÄÇÂª∫ËÆÆ‰∏ãËΩΩÂêé‰ΩøÁî®Êú¨Âú∞Â∫îÁî®Á®ãÂ∫èÊâìÂºÄ„ÄÇ", false);
            }
            else if (extension == ".xls")
            {
                ShowNotification("ËØ•Êñá‰ª∂‰∏∫ÊóßÁâà Excel (.xls) Ê†ºÂºèÔºåÂú®Á∫øÈ¢ÑËßàÂèØËÉΩ‰∏çÂÆåÊï¥„ÄÇÂª∫ËÆÆ‰∏ãËΩΩÂêé‰ΩøÁî®Êú¨Âú∞Â∫îÁî®Á®ãÂ∫èÊâìÂºÄ„ÄÇ", false);
            }
            
            if (previewIsImage)
            {
                var encodedPath = Uri.EscapeDataString(filePath);
                previewImageUrl = $"/api/files/download?path={encodedPath}";
            }
            else if (previewIsText)
            {
                // Read text content (limit to 1MB for preview)
                var fileInfo = new FileInfo(filePath);
                if (fileInfo.Length > 1024 * 1024)
                {
                    previewTextContent = "Êñá‰ª∂Â§™Â§ßÔºåÊó†Ê≥ïÈ¢ÑËßà„ÄÇËØ∑‰∏ãËΩΩÊñá‰ª∂Êü•Áúã„ÄÇ";
                }
                else
                {
                    var bytes = await FileManagerService.ReadFileAsync(filePath);
                    try
                    {
                        var utf8 = new System.Text.UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true);
                        previewTextContent = utf8.GetString(bytes);
                    }
                    catch (System.Text.DecoderFallbackException)
                    {
                        previewTextContent = "Êó†Ê≥ï‰ª• UTF-8 Ëß£Á†ÅËØ•Êñá‰ª∂ÂÜÖÂÆπÔºåËØ∑‰∏ãËΩΩÂêé‰ΩøÁî®ÂêàÈÄÇÁöÑÁ®ãÂ∫èÊâìÂºÄ„ÄÇ";
                    }
                }
            }
            else if (previewIsPdf || previewIsDocx || previewIsXlsx)
            {
                // For PDF and Office documents, we need to provide the download URL
                // Note: Path validation and access control is enforced by the backend API endpoint
                // via FileManagerService.IsPathAllowed() to prevent unauthorized file access
                var encodedPath = Uri.EscapeDataString(filePath);
                previewFileUrl = $"/api/files/download?path={encodedPath}";
            }
            
            showPreviewDialog = true;
            
            // Trigger JavaScript rendering for PDF and Office documents after dialog is shown
            if (previewIsPdf || previewIsDocx || previewIsXlsx)
            {
                // Ensure the dialog is rendered before triggering JavaScript rendering
                await InvokeAsync(StateHasChanged);
                await Task.Yield();
                await RenderDocument(extension);
            }
        }
        catch (Exception ex)
        {
            ShowNotification($"È¢ÑËßàÊñá‰ª∂Â§±Ë¥•: {ex.Message}", true);
        }
    }

    private async Task ClosePreviewDialog()
    {
        showPreviewDialog = false;
        
        // Cleanup document preview containers
        if (previewIsPdf || previewIsDocx || previewIsXlsx)
        {
            await JSRuntime.InvokeVoidAsync("documentPreview.cleanup", "documentPreviewContainer");
        }
        
        previewFilePath = string.Empty;
        previewFileName = string.Empty;
        previewImageUrl = string.Empty;
        previewTextContent = string.Empty;
        previewFileUrl = string.Empty;
        previewIsImage = false;
        previewIsText = false;
        previewIsPdf = false;
        previewIsDocx = false;
        previewIsXlsx = false;
    }
    
    private async Task RenderDocument(string extension)
    {
        try
        {
            object? result = null;
            if (extension == ".pdf")
            {
                result = await JSRuntime.InvokeAsync<object>("documentPreview.initPdfViewer", "documentPreviewContainer", previewFileUrl);
            }
            else if (extension == ".docx" || extension == ".doc")
            {
                result = await JSRuntime.InvokeAsync<object>("documentPreview.initDocxViewer", "documentPreviewContainer", previewFileUrl);
            }
            else if (extension == ".xlsx" || extension == ".xls")
            {
                result = await JSRuntime.InvokeAsync<object>("documentPreview.initXlsxViewer", "documentPreviewContainer", previewFileUrl);
            }
            
            // Check if rendering failed and display error in container
            if (result != null)
            {
                var resultDict = result as System.Text.Json.JsonElement?;
                if (resultDict.HasValue && resultDict.Value.TryGetProperty("success", out var successProp))
                {
                    if (!successProp.GetBoolean())
                    {
                        var errorMsg = resultDict.Value.TryGetProperty("error", out var errorProp) 
                            ? errorProp.GetString() ?? "Êú™Áü•ÈîôËØØ"
                            : "Êú™Áü•ÈîôËØØ";
                        await JSRuntime.InvokeVoidAsync("documentPreview.displayError", "documentPreviewContainer", $"ÊñáÊ°£Âä†ËΩΩÂ§±Ë¥•: {errorMsg}");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            // Display error in preview container instead of just showing notification
            try
            {
                await JSRuntime.InvokeVoidAsync("documentPreview.displayError", "documentPreviewContainer", "ÊñáÊ°£È¢ÑËßàÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï„ÄÇ");
            }
            catch
            {
                // Fallback to notification if JavaScript fails
                ShowNotification($"Ê∏≤ÊüìÊñáÊ°£Â§±Ë¥•: {ex.Message}", true);
            }
        }
    }

    // Favorites management methods
    private void ShowAddFavoriteDialog()
    {
        editingFavorite = null;
        favoriteName = Path.GetFileName(currentPath) ?? "Êñ∞Êî∂Ëóè";
        favoritePath = currentPath;
        favoriteIcon = "folder";
        favoriteMessage = string.Empty;
        favoriteSuccess = false;
        showFavoriteDialog = true;
    }

    private void ShowEditFavoriteDialog(FavoriteFolder favorite)
    {
        editingFavorite = favorite;
        favoriteName = favorite.Name;
        favoritePath = favorite.Path;
        favoriteIcon = favorite.Icon;
        favoriteMessage = string.Empty;
        favoriteSuccess = false;
        showFavoriteDialog = true;
    }

    private void CloseFavoriteDialog()
    {
        showFavoriteDialog = false;
        editingFavorite = null;
        favoriteName = string.Empty;
        favoritePath = string.Empty;
        favoriteIcon = "folder";
        favoriteMessage = string.Empty;
        favoriteSuccess = false;
    }

    private async Task SaveFavorite()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(favoriteName))
            {
                favoriteMessage = "ËØ∑ËæìÂÖ•Êî∂ËóèÂ§πÂêçÁß∞";
                favoriteSuccess = false;
                return;
            }

            if (favoriteName.Length > 200)
            {
                favoriteMessage = "Êî∂ËóèÂ§πÂêçÁß∞‰∏çËÉΩË∂ÖËøá200‰∏™Â≠óÁ¨¶";
                favoriteSuccess = false;
                return;
            }

            if (editingFavorite == null)
            {
                // Add new favorite
                await FileManagerService.AddFavoriteFolderAsync(favoriteName, favoritePath, favoriteIcon);
                favoriteMessage = "Ê∑ªÂä†Êî∂ËóèÊàêÂäü";
            }
            else
            {
                // Update existing favorite
                await FileManagerService.UpdateFavoriteFolderAsync(editingFavorite.Id, favoriteName, favoriteIcon);
                favoriteMessage = "Êõ¥Êñ∞Êî∂ËóèÊàêÂäü";
            }
            
            favoriteSuccess = true;
            
            // Reload favorites
            favoriteFolders = await FileManagerService.GetFavoriteFoldersAsync();
            
            // Close dialog after short delay
            await Task.Delay(1000);
            CloseFavoriteDialog();
        }
        catch (Exception ex)
        {
            favoriteMessage = $"Êìç‰ΩúÂ§±Ë¥•: {ex.Message}";
            favoriteSuccess = false;
        }
    }

    private async Task RemoveFavorite(int id)
    {
        try
        {
            await FileManagerService.RemoveFavoriteFolderAsync(id);
            ShowNotification("Âà†Èô§Êî∂ËóèÊàêÂäü", false);
            
            // Reload favorites
            favoriteFolders = await FileManagerService.GetFavoriteFoldersAsync();
        }
        catch (Exception ex)
        {
            ShowNotification($"Âà†Èô§Êî∂ËóèÂ§±Ë¥•: {ex.Message}", true);
        }
    }

    private string GetFavoriteIcon(string icon)
    {
        return icon switch
        {
            "star" => Icons.Material.Filled.Star,
            "description" => Icons.Material.Filled.Description,
            "download" => Icons.Material.Filled.Download,
            "photo_library" => Icons.Material.Filled.PhotoLibrary,
            "movie" => Icons.Material.Filled.Movie,
            "audiotrack" => Icons.Material.Filled.AudioFile,
            "work" => Icons.Material.Filled.Work,
            "school" => Icons.Material.Filled.School,
            "home" => Icons.Material.Filled.Home,
            _ => Icons.Material.Filled.Folder
        };
    }
    
    private string GetFavoriteOptionText(string icon)
    {
        return icon switch
        {
            "folder" => "Êñá‰ª∂Â§π",
            "star" => "ÊòüÊ†á",
            "description" => "ÊñáÊ°£",
            "download" => "‰∏ãËΩΩ",
            "photo_library" => "ÂõæÁâá",
            "movie" => "ËßÜÈ¢ë",
            "audiotrack" => "Èü≥‰πê",
            "work" => "Â∑•‰Ωú",
            "school" => "Â≠¶‰π†",
            "home" => "‰∏ªÈ°µ",
            _ => "Êñá‰ª∂Â§π"
        };
    }

    // Selection management methods
    private async Task HandleFileItemClick(string filePath, Microsoft.AspNetCore.Components.Web.MouseEventArgs? e)
    {
        if (isSelectionMode)
        {
            ToggleFileSelection(filePath);
        }
        else
        {
            await NavigateTo(filePath);
        }
    }

    private void ToggleSelectionMode()
    {
        isSelectionMode = !isSelectionMode;
        if (!isSelectionMode)
        {
            selectedFiles.Clear();
        }
    }

    private void ToggleFileSelection(string filePath)
    {
        if (selectedFiles.Contains(filePath))
        {
            selectedFiles.Remove(filePath);
        }
        else
        {
            selectedFiles.Add(filePath);
        }
    }

    private void ToggleSelectAll()
    {
        if (files == null) return;
        
        var selectableFiles = files.Where(f => f.Name != "..").ToList();
        
        if (selectedFiles.Count == selectableFiles.Count)
        {
            // Deselect all
            selectedFiles.Clear();
        }
        else
        {
            // Select all
            selectedFiles.Clear();
            foreach (var file in selectableFiles)
            {
                selectedFiles.Add(file.Path);
            }
        }
    }

    private bool IsFileSelected(string filePath)
    {
        return selectedFiles.Contains(filePath);
    }

    // Batch operation methods
    private void ShowBatchCopyDialog()
    {
        if (selectedFiles.Count == 0)
        {
            ShowNotification("ËØ∑ÂÖàÈÄâÊã©Ë¶ÅÂ§çÂà∂ÁöÑÊñá‰ª∂", true);
            return;
        }
        
        showBatchCopyDialog = true;
        batchCopyDestination = string.Empty;
        batchCopyMessage = string.Empty;
        batchCopySuccess = false;
    }

    private void CloseBatchCopyDialog()
    {
        showBatchCopyDialog = false;
        batchCopyDestination = string.Empty;
        batchCopyMessage = string.Empty;
        batchCopySuccess = false;
    }

    private async Task BatchCopyFiles()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(batchCopyDestination))
            {
                batchCopyMessage = "ËØ∑ËæìÂÖ•ÁõÆÊ†áË∑ØÂæÑ";
                batchCopySuccess = false;
                return;
            }

            await FileManagerService.BatchCopyAsync(selectedFiles.ToList(), batchCopyDestination);
            
            batchCopyMessage = $"ÊàêÂäüÂ§çÂà∂ {selectedFiles.Count} ‰∏™Êñá‰ª∂";
            batchCopySuccess = true;
            
            await CompleteBatchOperationAsync(CloseBatchCopyDialog);
        }
        catch (AggregateException ex)
        {
            batchCopyMessage = ex.Message;
            batchCopySuccess = false;
        }
        catch (Exception ex)
        {
            batchCopyMessage = $"Â§çÂà∂Â§±Ë¥•: {ex.Message}";
            batchCopySuccess = false;
        }
    }

    private void ShowBatchMoveDialog()
    {
        if (selectedFiles.Count == 0)
        {
            ShowNotification("ËØ∑ÂÖàÈÄâÊã©Ë¶ÅÁßªÂä®ÁöÑÊñá‰ª∂", true);
            return;
        }
        
        showBatchMoveDialog = true;
        batchMoveDestination = string.Empty;
        batchMoveMessage = string.Empty;
        batchMoveSuccess = false;
    }

    private void CloseBatchMoveDialog()
    {
        showBatchMoveDialog = false;
        batchMoveDestination = string.Empty;
        batchMoveMessage = string.Empty;
        batchMoveSuccess = false;
    }

    private async Task BatchMoveFiles()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(batchMoveDestination))
            {
                batchMoveMessage = "ËØ∑ËæìÂÖ•ÁõÆÊ†áË∑ØÂæÑ";
                batchMoveSuccess = false;
                return;
            }

            await FileManagerService.BatchMoveAsync(selectedFiles.ToList(), batchMoveDestination);
            
            batchMoveMessage = $"ÊàêÂäüÁßªÂä® {selectedFiles.Count} ‰∏™Êñá‰ª∂";
            batchMoveSuccess = true;
            
            await CompleteBatchOperationAsync(CloseBatchMoveDialog);
        }
        catch (AggregateException ex)
        {
            batchMoveMessage = ex.Message;
            batchMoveSuccess = false;
        }
        catch (Exception ex)
        {
            batchMoveMessage = $"ÁßªÂä®Â§±Ë¥•: {ex.Message}";
            batchMoveSuccess = false;
        }
    }

    private void ShowBatchDeleteDialog()
    {
        if (selectedFiles.Count == 0)
        {
            ShowNotification("ËØ∑ÂÖàÈÄâÊã©Ë¶ÅÂà†Èô§ÁöÑÊñá‰ª∂", true);
            return;
        }
        
        showBatchDeleteDialog = true;
        batchDeleteMessage = string.Empty;
        batchDeleteSuccess = false;
    }

    private void CloseBatchDeleteDialog()
    {
        showBatchDeleteDialog = false;
        batchDeleteMessage = string.Empty;
        batchDeleteSuccess = false;
    }

    private async Task BatchDeleteFiles()
    {
        try
        {
            await FileManagerService.BatchDeleteAsync(selectedFiles.ToList());
            
            batchDeleteMessage = $"ÊàêÂäüÂà†Èô§ {selectedFiles.Count} ‰∏™Êñá‰ª∂";
            batchDeleteSuccess = true;
            
            await CompleteBatchOperationAsync(CloseBatchDeleteDialog);
        }
        catch (AggregateException ex)
        {
            batchDeleteMessage = ex.Message;
            batchDeleteSuccess = false;
        }
        catch (Exception ex)
        {
            batchDeleteMessage = $"Âà†Èô§Â§±Ë¥•: {ex.Message}";
            batchDeleteSuccess = false;
        }
    }

    private async Task CompleteBatchOperationAsync(Action closeDialog)
    {
        // Clear selection and close dialog after short delay
        await Task.Delay(DIALOG_AUTO_CLOSE_DELAY_MS);
        selectedFiles.Clear();
        closeDialog();
        await RefreshFiles();
    }

    private async Task BatchDownloadFiles()
    {
        try
        {
            if (selectedFiles.Count == 0)
            {
                ShowNotification("ËØ∑ÂÖàÈÄâÊã©Ë¶Å‰∏ãËΩΩÁöÑÊñá‰ª∂", true);
                return;
            }

            // TODO: In a production system, consider creating a ZIP file for batch downloads
            // For now, download each file individually
            var fileCount = 0;
            foreach (var filePath in selectedFiles)
            {
                // Only download files, not directories - check using file info from current list
                var fileInfo = files?.FirstOrDefault(f => f.Path == filePath);
                if (fileInfo != null && !fileInfo.IsDirectory)
                {
                    await DownloadFile(filePath);
                    fileCount++;
                }
            }
            
            ShowNotification($"ÂºÄÂßã‰∏ãËΩΩ {fileCount} ‰∏™Êñá‰ª∂", false);
            selectedFiles.Clear();
            isSelectionMode = false;
        }
        catch (Exception ex)
        {
            ShowNotification($"‰∏ãËΩΩÂ§±Ë¥•: {ex.Message}", true);
        }
    }
}
